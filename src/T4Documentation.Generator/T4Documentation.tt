<#
/*

*/
#>
<#@ template language="C#" debug="true" hostspecific="true" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="Microsoft.VisualStudio.Shell.Interop" #>
<#@ assembly name="Microsoft.VisualBasic" #>
<#@ assembly name="EnvDTE" #>
<#@ assembly name="EnvDTE80" #>
<#@ assembly name="VSLangProj" #>
<#@ assembly name="System.Xml" #>
<#@ assembly name="System.Xml.Linq" #>
<#@ import namespace="System.Xml" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Text.RegularExpressions" #>
<#@ import namespace="Microsoft.VisualStudio.Shell.Interop" #>
<#@ import namespace="EnvDTE" #>
<#@ import namespace="EnvDTE80" #>
<#@ import namespace="Microsoft.VisualStudio.TextTemplating" #>
<#@ output extension=".txt" #>
<# // To debug, uncomment the next two lines !! 
  //System.Diagnostics.Debugger.Launch();
  //System.Diagnostics.Debugger.Break();
#>
<#settings=DocumentSettings.Load(Host);#>
<#PrepareDataToRender(this); #>
<#var manager = Manager.Create(Host, GenerationEnvironment); #>
<#
/*
Documentation home links start
*/
#>
<# if(settings.SplitIntoMultipleFiles) {#>
<#foreach (var folderItem in settings.RootFoldersToDocument) {
string folder = folderItem.Key; string folderDescription = folderItem.Value;#>
<# RenderHeaderOne(folder); #>
<# if(!string.IsNullOrEmpty(folderDescription)) { #>
<# RenderParagraph(folderDescription); #>
<#}#>
<# RenderAnchor(settings.WikiLinkPrefix + folder, "See full " + folder.ToLower() + " reference."); #>
<#}#>
<#}#>
<#
/*
Documentation home links end
*/
#>
<#
/*
Root Folder iteration start*/
#>
<#foreach (var folderItem in settings.RootFoldersToDocument.Where(x => ProjectItemInfos.Any(y => y.Folder == x.Key))) {
string folder = folderItem.Key; string folderDescription = folderItem.Value; #>
<#manager.StartNewFile(folder + ".txt"); #>
<# RenderHeaderOne(folder); #>
<# if(!string.IsNullOrEmpty(folderDescription)) { #>
<# RenderParagraph(folderDescription); #>
<#}#>
<#foreach (string infoItemType in ProjectItemInfos.Where(x => x.Folder == folder).OrderBy(x => x.Type).Select(x => x.TypePlural).ToArray().Distinct()) {#>
<# RenderHeaderTwo(infoItemType); #>
<#foreach (ProjectItemInfo infoItem in ProjectItemInfos.Where(x => x.TypePlural == infoItemType && x.Folder == folder)) { #>
<# RenderHeaderThree(infoItem.Name + " " + infoItem.Type); #>
<# if(!string.IsNullOrEmpty(infoItem.Namespace)) { #>
<# RenderParagraph("Namespace: " + infoItem.Namespace); #>
<#}#>
<# if(!string.IsNullOrEmpty(infoItem.Summary)) { #>
<# RenderParagraph("Summary: " + infoItem.Summary); #>
<#}#>
<# if(infoItem.UsingStatements != null && infoItem.UsingStatements.Any() && settings.IncludeUsingStatements) { #>
<#foreach (var usingStatement in infoItem.UsingStatements.Where(x=> !string.IsNullOrEmpty(x.Namespace))) { #>
<# RenderBulletListItem("Using: " + usingStatement.Namespace); #>
<# WriteLine(""); #>
<#}#>
<#}#>
<# if(!string.IsNullOrEmpty(infoItem.Example)) { #>
<# RenderHeaderFour("Example"); #>
<# RenderParagraph(infoItem.Example); #>
<#}#>
<# if(!string.IsNullOrEmpty(infoItem.ExampleCode)) { #>
<# RenderHeaderFour("Example Code"); #>
<# RenderCode(infoItem.ExampleCode); #>
<#}#>
<#
/*
Properties start
*/
#>
<# if(infoItem.PropertyInfos != null && infoItem.PropertyInfos.Any()) { #>
<# RenderPropertiesTable(infoItem.PropertyInfos); #>
<#}#>
<#
/*
Properties end
*/
#>
<#
/*
Methods start
*/
#>
<# if(infoItem.MethodInfos != null && infoItem.MethodInfos.Any()) { #>
<# RenderMethodsTable(infoItem.MethodInfos); #>
<#}#>
<#
/*
Methods end
*/
#>
<# if(!string.IsNullOrEmpty(infoItem.Remarks)) { #>
<# RenderHeaderFour("Remarks"); #>
<# RenderParagraph(infoItem.Remarks); #>
<#}#>
<#}#>
<#}#>
<#manager.EndBlock(); #>
<#}#>
<#
/*
Root Folder iteration End
*/
#>
<#settings.SaveChanges(manager); #>
<#manager.Process(settings.SplitIntoMultipleFiles); #>

<#@ Include File="T4Documentation.tt.MediaWiki.provider.t4" #>


<#+ 
static DocumentSettings settings;
const string ControllerSuffix = "Controller";

static DTE Dte;
static Project Project;
static string AppRoot;

static TextTransformation TT;
static string T4FileName;
static string T4Folder;

static HashSet<ProjectItemInfo> ProjectItemInfos;

void PrepareDataToRender(TextTransformation tt)
{
	
    TT = tt;
    T4FileName = Path.GetFileName(Host.TemplateFile);
    T4Folder = Path.GetDirectoryName(Host.TemplateFile);
    ProjectItemInfos = new HashSet<ProjectItemInfo>();

    // Get the DTE service from the host
    var serviceProvider = Host as IServiceProvider;
    if (serviceProvider != null)
    {
        Dte = (EnvDTE.DTE)serviceProvider.GetService(typeof(EnvDTE.DTE));
    }

    // Fail if we couldn't get the DTE. This can happen when trying to run in TextTransform.exe
    if (Dte == null)
    {
        throw new Exception("T4MVC can only execute through the Visual Studio host");
    }

    Project = GetProjectContainingT4File(Dte);

    if (Project == null)
    {
        Error("Could not find the VS Project containing the T4 file.");
        return;
    }

    // Get the path of the root folder of the app
    AppRoot = Path.GetDirectoryName(Project.FullName) + '\\';

    // Process controllers and views from project root
    ProcessProjectRoot(Project);

}

//keep
Project GetProjectContainingT4File(DTE dte)
{

    // Find the .tt file's ProjectItem
    ProjectItem projectItem = dte.Solution.FindProjectItem(Host.TemplateFile);

    // If the .tt file is not opened, open it
    if (projectItem.Document == null)
        projectItem.Open(EnvDTE.Constants.vsViewKindCode);

    return projectItem.ContainingProject;
}

void ProcessProjectRoot(Project project)
{
	
	if(settings.RootFoldersToDocument != null && settings.RootFoldersToDocument.Any())
	{
		foreach (string folder in settings.RootFoldersToDocument.Select(x=>x.Key)) {
			// Get the folder
			ProjectItem folderToProcess = Functions.GetProjectItem(project, folder);

			// Process areas folder
			if (folderToProcess != null)
			{
				RecursivelyProcessPrjectItems(folderToProcess.ProjectItems, folder);
			}
		
		}
	}
    else
	{
		
		ProcessRootProjectItems(project);
	}
}

void ProcessRootProjectItems(Project project)
{
	List<KeyValuePair<string, string>> folderItems = new List<KeyValuePair<string, string>>();

    foreach (EnvDTE.ProjectItem item in project.ProjectItems)
    {	
		if(Functions.IsFolder(item))
		{	
			
			folderItems.Add(new KeyValuePair<string, string>(item.Name,""));
				

		}
      
    }

	settings.RootFoldersToDocument = new XmlNameValueCollection(folderItems, "Folder");
	ProcessProjectRoot(project);
	
}

void RecursivelyProcessPrjectItems(ProjectItems items, string folder)
{
	foreach (ProjectItem item in items)
	{
		if(!Functions.IsFolder(item))
		{
			if (item.FileCodeModel != null)
			{
				FileCodeModel2 codeModel2 = item.FileCodeModel as FileCodeModel2;

				List<UsingStatement> usingStatements = new List<UsingStatement>();

				//these are global using statements for the file
				foreach (var type in codeModel2.CodeElements.OfType<CodeImport>())
				{
					var usingStatement = new UsingStatement{
						Namespace = type.Namespace
					};

					usingStatements.Add(usingStatement);
				}

			

				// Process all the elements that are namespaces
				foreach (var ns in codeModel2.CodeElements.OfType<CodeNamespace>())
				{
					List<UsingStatement> nameSpaceUsingStatements = new List<UsingStatement>();

					nameSpaceUsingStatements.AddRange(usingStatements);

					//this should be processed first
					foreach (var type in ns.Members.OfType<CodeImport>())
					{
						

						if(nameSpaceUsingStatements.Count(x => x.Namespace == type.Namespace) == 0)
						{
							var namespaceUsingStatement = new UsingStatement{
								Namespace = type.Namespace
							};

							nameSpaceUsingStatements.Add(namespaceUsingStatement);
						}
						
					}


					foreach (var type in ns.Members.OfType<CodeClass2>())
					{
						ProcessType(type, folder,nameSpaceUsingStatements);
					}

					
					foreach (var type in ns.Members.OfType<CodeInterface>())
					{
						ProcessType(type, folder,nameSpaceUsingStatements);
					}

					foreach (var type in ns.Members.OfType<CodeStruct2>())
					{
						ProcessType(type, folder,nameSpaceUsingStatements);
					}

					
				}

			}
			else
			{
				//Still not sure what to do with non-FileCodeModel files
				//public string Name { get; set; }
				//public string Type { get; set; }
				//public string Namespace { get; set;}
				//public string Description { get; set; }
				//public string Folder { get; set; }
				//there is no code model

				//ProjectItemInfo projectItemInfoItem = new ProjectItemInfo{
				//	Name = item.Name,
				//	Folder = folder
				//};

				//ProjectItemInfos.Add(projectItemInfoItem);
			}
		}
		else
		{
			RecursivelyProcessPrjectItems(item.ProjectItems,folder);
		}

	}
}

void ProcessType(CodeStruct2 type, string folder, List<UsingStatement> usingStatements)
{
	IEnumerable<CodeFunction2> methods = Functions.GetMethods(type);
	List<MethodInfo> methodInfos = Functions.GetMethodInfo(methods);

	IEnumerable<CodeProperty2> properties = Functions.GetProperties(type);
	List<PropertyInfo> propertyInfos = Functions.GetPropertyInfo(properties);

	ProjectItemInfo projectItemInfoItem = new ProjectItemInfo{
		Name = type.Name,
		Folder = folder,
		Namespace = type.Namespace != null ? type.Namespace.Name : String.Empty,
		UsingStatements = usingStatements,
		PropertyInfos = propertyInfos,
		MethodInfos = methodInfos
	};

	if(!string.IsNullOrEmpty(type.DocComment))
	{
		projectItemInfoItem.Summary = Functions.GetTagContent("summary", type.DocComment);
		projectItemInfoItem.Remarks = Functions.GetTagContent("remarks", type.DocComment);
		projectItemInfoItem.Example = Functions.GetTagContent("example", type.DocComment);
		projectItemInfoItem.ExampleCode = Functions.GetTagContent("code",  type.DocComment);
	}
	
	Functions.SetProjectItemInfoType(projectItemInfoItem,type);

	ProjectItemInfos.Add(projectItemInfoItem);
}

void ProcessType(CodeInterface type, string folder, List<UsingStatement> usingStatements)
{
	IEnumerable<CodeFunction2> methods = Functions.GetMethods(type);
	List<MethodInfo> methodInfos = Functions.GetMethodInfo(methods);

	IEnumerable<CodeProperty2> properties = Functions.GetProperties(type);
	List<PropertyInfo> propertyInfos = Functions.GetPropertyInfo(properties);

	ProjectItemInfo projectItemInfoItem = new ProjectItemInfo{
		Name = type.Name,
		Folder = folder,
		Namespace = type.Namespace != null ? type.Namespace.Name : String.Empty,
		UsingStatements = usingStatements,
		PropertyInfos = propertyInfos,
		MethodInfos = methodInfos
	};

	if(!string.IsNullOrEmpty(type.DocComment))
	{
		projectItemInfoItem.Summary = Functions.GetTagContent("summary", type.DocComment);
		projectItemInfoItem.Remarks = Functions.GetTagContent("remarks", type.DocComment);
		projectItemInfoItem.Example = Functions.GetTagContent("example", type.DocComment);
		projectItemInfoItem.ExampleCode = Functions.GetTagContent("code",  type.DocComment);
	}
	
	Functions.SetProjectItemInfoType(projectItemInfoItem,type);

	ProjectItemInfos.Add(projectItemInfoItem);
}

//we are processing our classes here
void ProcessType(CodeClass2 type, string folder, List<UsingStatement> usingStatements)
{
	
	IEnumerable<CodeFunction2> methods = Functions.GetMethods(type);
	List<MethodInfo> methodInfos = Functions.GetMethodInfo(methods);
	
	
	IEnumerable<CodeProperty2> properties = Functions.GetProperties(type);
	List<PropertyInfo> propertyInfos = Functions.GetPropertyInfo(properties);


	ProjectItemInfo projectItemInfoItem = new ProjectItemInfo{
		Name = type.Name,
		Folder = folder,
		Namespace = type.Namespace != null ? type.Namespace.Name : String.Empty,
		UsingStatements = usingStatements,
		PropertyInfos = propertyInfos,
		MethodInfos = methodInfos
	};

	if(!string.IsNullOrEmpty(type.DocComment))
	{
		projectItemInfoItem.Summary = Functions.GetTagContent("summary", type.DocComment);
		projectItemInfoItem.Remarks = Functions.GetTagContent("remarks", type.DocComment);
		projectItemInfoItem.Example = Functions.GetTagContent("example", type.DocComment);
		projectItemInfoItem.ExampleCode = Functions.GetTagContent("code",  type.DocComment);
	}

	Functions.SetProjectItemInfoType(projectItemInfoItem,type);

	ProjectItemInfos.Add(projectItemInfoItem);
}


  /// Custom class to allow string arrays to be read and written to/from settings
    public class XmlStringArray : XmlSettingsBase, IEnumerable<string>
    {
        public XmlStringArray(IEnumerable<string> items, string name)
        {
            this._items = items;
            this._name = name;
            SetSaveAsChild(this, true);
        }

        string _name;
        IEnumerable<string> _items;

        protected override void Load(System.Xml.Linq.XElement xml)
        {
            var items = new List<string>();
            foreach (var item in xml.Elements(this._name))
            {
                items.Add(item.Value);
            }
            this._items = items;
            SetNeedsSave(this, false);
        }

        protected override void Save(System.Xml.XmlWriter writer)
        {
            if (this._items == null || !this._items.Any())
            {
                WriteCommentedProperty(writer, this._name);
                return;
            }

            foreach (var item in this._items)
            {
                writer.WriteElementString(this._name, item);
            }
        }

        public IEnumerator<string> GetEnumerator()
        {
            return this._items.GetEnumerator();
        }

        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
        {
            return this.GetEnumerator();
        }
    }

 public class XmlNameValueCollection : XmlSettingsBase, IEnumerable<KeyValuePair<string, string>>
    {
        public XmlNameValueCollection(IEnumerable<KeyValuePair<string, string>> items, string name)
        {
            this._items = items;
            this._name = name;
            SetSaveAsChild(this, true);
        }

        string _name;
        IEnumerable<KeyValuePair<string, string>> _items;

        protected override void Load(System.Xml.Linq.XElement xml)
        {
            var items = new List<KeyValuePair<string, string>>();
            foreach (var item in xml.Elements(this._name))
            {
                items.Add(new KeyValuePair<string, string>(item.Attribute("name").Value, item.Attribute("description").Value));
            }
            this._items = items;
            SetNeedsSave(this, false);
        }

        protected override void Save(System.Xml.XmlWriter writer)
        {
            if (this._items == null || !this._items.Any())
            {
                WriteCommentedProperty(writer, this._name);
                return;
            }

            foreach (var item in this._items)
            {
                writer.WriteElementString(this._name, item.ToString());
            }
        }

        public IEnumerator<KeyValuePair<string, string>> GetEnumerator()
        {
            return this._items.GetEnumerator();
        }

        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
        {
            return this.GetEnumerator();
        }
    }


    /// Base XmlSettings class, responsible for reading/writing the settigns file contents, all settings other 
    /// than string convertable types should decend from this class
    public abstract class XmlSettingsBase
    {
        protected XmlSettingsBase()
        {
            this.NeedsSave = true;
        }

        protected virtual void Init()
        {
        }

        protected bool SaveAsChild { get; private set; }

        protected bool NeedsSave { get; private set; }

        protected static void SetSaveAsChild(XmlSettingsBase settings, bool value)
        {
            settings.SaveAsChild = value;
        }

        protected static void SetNeedsSave(XmlSettingsBase settings, bool value)
        {
            settings.NeedsSave = value;
        }

        protected static void WriteCommentedProperty(System.Xml.XmlWriter writer, string name)
        {
            writer.WriteComment(string.Concat("<", name, "></", name, ">"));
        }

        protected static void WritePropertyDesc(System.Xml.XmlWriter writer, System.ComponentModel.PropertyDescriptor property)
        {
            var desc = property.Attributes.OfType<System.ComponentModel.DescriptionAttribute>().FirstOrDefault();
            if (desc != null)
            {
                writer.WriteComment(desc.Description);
            }
        }

        protected virtual void Load(System.Xml.Linq.XElement xml)
        {
            this.NeedsSave = false;
            int matched = 0;
            int read = 0;
            foreach (System.ComponentModel.PropertyDescriptor property in System.ComponentModel.TypeDescriptor.GetProperties(this))
            {
                object pvalue;
                if (typeof(XmlSettingsBase).IsAssignableFrom(property.PropertyType) || (((pvalue = property.GetValue(this)) != null) && typeof(XmlSettingsBase).IsAssignableFrom(pvalue.GetType())))
                {
                    read++;
                    var value = xml.Element(property.Name);
                    if (value != null)
                    {
                        var settings = (XmlSettingsBase)property.GetValue(this);
                        settings.Load(value);
                        if (!settings.NeedsSave)
                            matched++;
                        settings.SaveAsChild = true;
                    }
                }
                else if (!property.IsReadOnly)
                {
                    read++;
                    var value = xml.Element(property.Name);
                    if (value != null)
                    {
                        if (property.Converter.CanConvertFrom(typeof(string)))
                        {
                            matched++;
                            property.SetValue(this, property.Converter.ConvertFromString(value.Value));
                        }
                        else
                        {
                            System.Reflection.MethodBase parser = property.PropertyType.GetMethod("Parse", new Type[] { typeof(string) });
                            if (parser == null)
                                parser = property.PropertyType.GetConstructor(new Type[] { typeof(string) });

                            if (parser != null)
                            {
                                matched++;
                                property.SetValue(this, parser.Invoke(null, new Object[] { value.Value }));
                            }
                        }
                    }
                }
            }
            this.NeedsSave = this.NeedsSave || (matched < read);
        }

        protected virtual void Save(System.Xml.XmlWriter writer)
        {
            foreach (System.ComponentModel.PropertyDescriptor property in System.ComponentModel.TypeDescriptor.GetProperties(this))
            {
                var value = property.GetValue(this);
                WritePropertyDesc(writer, property);
                if (value != null)
                {
                    if (typeof(XmlSettingsBase).IsAssignableFrom(value.GetType()))
                    {
                        var settings = (XmlSettingsBase)property.GetValue(this);
                        if ((settings != null) && settings.SaveAsChild)
                        {
                            writer.WriteStartElement(property.Name);
                            settings.Save(writer);
                            writer.WriteEndElement();
                        }
                    }
                    else if (!property.IsReadOnly)
                    {
                        writer.WriteElementString(property.Name, property.Converter.ConvertToString(value));
                    }
                }
                else
                {
                    WriteCommentedProperty(writer, property.Name);
                }
            }
        }
    }

public class DocumentSettings : XmlSettings
    {
        public static DocumentSettings Load(ITextTemplatingEngineHost host)
        {
            return Load<DocumentSettings>(host);
        }

        public DocumentSettings()
        {
            this.RootFoldersToDocument = new XmlNameValueCollection(new List<KeyValuePair<string, string>> (), "Folder");

            this.SplitIntoMultipleFiles = true;

            this.IncludeUsingStatements = true;
        }

        [System.ComponentModel.Description("These are the root folders taht we will document")]
        public XmlNameValueCollection RootFoldersToDocument { get; set; }

        [System.ComponentModel.Description("If true,the template output will be split into multiple files.")]
        public bool SplitIntoMultipleFiles { get; set; }

        [System.ComponentModel.Description("If true, includes using statements.")]
        public bool IncludeUsingStatements { get; set; }

        [System.ComponentModel.Description("Prefixes WIKI links.")]
        public string WikiLinkPrefix { get; set; } = "";

    }

    /// This is the base class for the standard settings, the main settings class should inherit from this
    /// one since it provides the methods to interact with the T4 system and EnvDTE. Sub-properties can
    /// just inherit from XmlSettingsBase.
    public abstract class XmlSettings : XmlSettingsBase
    {
        protected static T Load<T>(ITextTemplatingEngineHost host) where T : XmlSettings, new()
        {
            T settings = new T();
            settings.Init(host);
            return settings;
        }

        void Init(ITextTemplatingEngineHost host)
        {
           
            this.TemplateFile = Path.GetFileName(host.TemplateFile);
            this.TemplateFolder = Path.GetDirectoryName(host.TemplateFile);
           
            // Get the DTE service from the host
            var serviceProvider = host as IServiceProvider;
            if (serviceProvider != null)
            {
                this.DTE = (EnvDTE.DTE)serviceProvider.GetService(typeof(EnvDTE.DTE));
            }

            // Fail if we couldn't get the DTE. This can happen when trying to run in TextTransform.exe
            if (this.DTE == null)
            {
                throw new Exception("T4Build can only execute through the Visual Studio host");
            }



            this.ProjectItem = this.DTE.Solution.FindProjectItem(host.TemplateFile);

            // If the .tt file is not opened, open it
            if (this.ProjectItem.Document == null)
                this.ProjectItem.Open(EnvDTE.Constants.vsViewKindCode);

            this.Project = this.ProjectItem.ContainingProject;

            if (Project == null)
            {
                throw new Exception("Could not find the VS Project containing the T4 file.");
            }

            this.Load();
            this.Init();
        }

        public string TemplateFile { get; private set; }

        public string TemplateFolder { get; private set; }

        public DTE DTE { get; private set; }

        public ProjectItem ProjectItem { get; private set; }

        public Project Project { get; private set; }

        ProjectItem FindProjectItemRecursive(ProjectItems items, string name)
        {
            if (items == null)
                return null;

            foreach (ProjectItem item in items)
            {
                if (item.Name.Equals(name) || item.Name.StartsWith(name + "."))
                    return item;
                var found = FindProjectItemRecursive(item.ProjectItems, name);
                if (found != null)
                    return found;
            }

            return null;
        }

        protected ProjectItem FindProjectItem(string name)
        {
            return this.FindProjectItemRecursive(this.Project.ProjectItems, name);
        }

        protected string SettingsFile
        {
            get
            {
                return Path.Combine(this.TemplateFolder, string.Concat(this.TemplateFile, ".settings.xml"));
            }
        }

        void Load()
        {
            if (System.IO.File.Exists(this.SettingsFile))
                try
                {
                    this.Load(System.Xml.Linq.XElement.Load(this.SettingsFile));
                }
                catch { throw; }
        }

        public void SaveChanges(Manager manager)
        {
            // Avoid saving if we dont need to;
            if (!this.NeedsSave)
                return;

            if (manager.FileOkToWrite(this.SettingsFile))
            {
                var settings = new System.Xml.XmlWriterSettings
                {
                    Indent = true
                };
                using (var writer = System.Xml.XmlWriter.Create(this.SettingsFile, settings))
                {
                    writer.WriteStartDocument();
                    writer.WriteStartElement(this.GetType().Name);
                    this.Save(writer);
                    writer.WriteEndElement();
                    writer.WriteEndDocument();
                }

                var item = this.ProjectItem.Collection.AddFromFile(this.SettingsFile);
                item.Properties.Item("ItemType").Value = "None";
            }
            else
            {
                TT.Error("Cannot save settings file! " + this.SettingsFile);
            }
                
        }
    }

	 /// <summary>
    ///     A library of ad-hoc functions for use in the document generator.
    /// </summary>
    public static class Functions
    {
        /// <summary>
        ///     Converts a collection of CodeFunction2 objects to a collection of domain specific MethodInfo objects.
        /// </summary>
        public static List<MethodInfo> GetMethodInfo(IEnumerable<CodeFunction2> functions)
        {
            var methodInfos = new List<MethodInfo>();

            if (functions != null && functions.Any())
            {
                foreach (var function in functions)
                {
                    var parameters = GetParameters(function);
                    var parameterInfos = GetParamterInfo(parameters);

                    var methodInfo = new MethodInfo
                    {
                        Access = GetAccess(function.Access, function.IsShared, function.MustImplement),
                        Name = function.Name,
                        ReturnType = function.Type.AsString,
                        ParameterInfos = parameterInfos
                    };

                    if (!string.IsNullOrEmpty(function.DocComment))
                    {
                        methodInfo.Summary = GetTagContent("summary", function.DocComment);
                        methodInfo.Remarks = GetTagContent("remarks", function.DocComment);
                        methodInfo.Example = GetTagContent("example", function.DocComment);
                        methodInfo.ExampleCode = GetTagContent("code", function.DocComment);
                    }

                    methodInfos.Add(methodInfo);
                }
            }

            return methodInfos;
        }

        /// <summary>
        ///     Converts a collection of CodeParameter objects to a collection of domain specific ParameterInfo objects.
        /// </summary>
        public static List<ParameterInfo> GetParamterInfo(IEnumerable<CodeParameter> parameters)
        {
            var paramterInfos = new List<ParameterInfo>();

            if (parameters != null && parameters.Any())
            {
                foreach (var parameter in parameters)
                {
                    var paramterInfo = new ParameterInfo
                    {
                        Name = parameter.Name,
                        Type = parameter.Type.AsString
                    };

                    paramterInfos.Add(paramterInfo);
                }
            }

            return paramterInfos;
        }

        /// <summary>
        ///     Converts a collection of CodeProperty2 objects to a collection of domain specific PropertyInfo objects.
        /// </summary>
        public static List<PropertyInfo> GetPropertyInfo(IEnumerable<CodeProperty2> properties)
        {
            var propertyInfos = new List<PropertyInfo>();

            if (properties != null && properties.Any())
            {
                foreach (var property in properties)
                {
                    var propertyInfo = new PropertyInfo
                    {
                        Access = GetAccess(property.Access, property.IsShared, false),
                        Name = property.Name,
                        Type = property.Type.AsString
                    };

                    if (!string.IsNullOrEmpty(property.DocComment))
                    {
                        propertyInfo.Summary = GetTagContent("summary", property.DocComment);
                        propertyInfo.Remarks = GetTagContent("remarks", property.DocComment);
                        propertyInfo.Example = GetTagContent("example", property.DocComment);
                        propertyInfo.ExampleCode = GetTagContent("code", property.DocComment);
                    }

                    propertyInfos.Add(propertyInfo);
                }
            }

            return propertyInfos;
        }

        /// <summary>
        /// Returns a descriptive string of access, static and abtract status'
        /// </summary>
        /// <param name="access"></param>
        /// <param name="isShared"></param>
        /// <param name="isAbstract"></param>
        /// <returns></returns>
        /// <code>
        /// var methodInfo = new MethodInfo
        ///  {
        ///      Access = GetAccess(function.Access, function.IsShared, function.MustImplement),
        ///      Name = function.Name,
        ///      ReturnType = function.Type.AsString,
        ///      ParameterInfos = parameterInfos
        ///  };
        /// </code>
        public static string GetAccess(vsCMAccess access, bool isShared, bool isAbstract)
        {
            var sb = new StringBuilder();

            switch (access)
            {
                case vsCMAccess.vsCMAccessPublic:
                    sb.Append("Public");
                    break;
                case vsCMAccess.vsCMAccessProjectOrProtected:
                case vsCMAccess.vsCMAccessProtected:
                    sb.Append("Protected");
                    break;
                case vsCMAccess.vsCMAccessAssemblyOrFamily:
                    sb.Append("Internal");
                    break;
                case vsCMAccess.vsCMAccessPrivate:
                default:
                    sb.Append("Private");
                    break;
            }

            if (isShared)
            {
                sb.Append(" static");
            }

            if (isAbstract)
            {
                sb.Append(" abstract");
            }

            return sb.ToString();
        }

        /// <summary>
        ///     Returns the value of a specific xml tag from an input string.
        /// </summary>
        public static string GetTagContent(string tagName, string input)
        {
            var sb = new StringBuilder();

            try
            {
                var xmldoc = new XmlDocument();
                xmldoc.LoadXml(input);

                var nodeList = xmldoc.GetElementsByTagName(tagName);
             
                foreach (XmlNode node in nodeList)
                {
                    sb.Append(node.InnerText.Trim());
                }
            }
            catch (Exception ex)
            {
                sb.Append("Ensure all character are valid XML symbols. eg; '&' should be '&amp;'.");
                sb.Append(ex.Message);
            }


            return sb.ToString();
        }

        /// <summary>
        ///     Tests a CodeFunction2's function kind.
        /// </summary>
        /// <param name="f"></param>
        /// <param name="kind"></param>
        /// <returns></returns>
        public static bool TestFunctionKind(CodeFunction2 f, vsCMFunction kind)
        {
            try
            {
                return f.FunctionKind == kind;
            }
            catch
            {
                // FunctionKind blows up in some cases. Just ignore.
                return false;
            }
        }

        /// <summary>
        ///     Return all the CodeFunction2 objects in the CodeStruct2's member collection.
        /// </summary>
        /// <param name="codeStruct"></param>
        /// <returns></returns>
        public static IEnumerable<CodeFunction2> GetMethods(CodeStruct2 codeStruct)
        {
            return codeStruct.Members.OfType<CodeFunction2>()
                .Where(f => TestFunctionKind(f, vsCMFunction.vsCMFunctionFunction));
        }

        /// <summary>
        ///     Return all the CodeFunction2 objects in the CodeClass2's member collection.
        /// </summary>
        /// <param name="codeClass"></param>
        /// <returns></returns>
        public static IEnumerable<CodeFunction2> GetMethods(CodeClass2 codeClass)
        {
            return codeClass.Members.OfType<CodeFunction2>()
                .Where(f => TestFunctionKind(f, vsCMFunction.vsCMFunctionFunction));
        }


        /// <summary>
        ///     Return all the CodeFunction2 objects in the CodeInterface's member collection.
        /// </summary>
        /// <param name="codeInterface"></param>
        /// <returns></returns>
        public static IEnumerable<CodeFunction2> GetMethods(CodeInterface codeInterface)
        {
            return codeInterface.Members.OfType<CodeFunction2>()
                .Where(f => TestFunctionKind(f, vsCMFunction.vsCMFunctionFunction));
        }


        /// <summary>
        ///     Return all the CodeProperty2 objects in the CodeClass2's member collection.
        /// </summary>
        /// <param name="codeClass"></param>
        /// <returns></returns>
        public static IEnumerable<CodeProperty2> GetProperties(CodeClass2 codeClass)
        {
            return codeClass.Members.OfType<CodeProperty2>();
        }

        /// <summary>
        ///     Return all the CodeProperty2 objects in the CodeInterface's member collection.
        /// </summary>
        /// <param name="codeInterface"></param>
        /// <returns></returns>
        public static IEnumerable<CodeProperty2> GetProperties(CodeInterface codeInterface)
        {
            return codeInterface.Members.OfType<CodeProperty2>();
        }

        /// <summary>
        ///     Return all the CodeProperty2 objects in the CodeStruct2's member collection.
        /// </summary>
        /// <param name="codeStruct"></param>
        /// <returns></returns>
        public static IEnumerable<CodeProperty2> GetProperties(CodeStruct2 codeStruct)
        {
            return codeStruct.Members.OfType<CodeProperty2>();
        }

        /// <summary>
        ///     Return all the CodeParameter objects in the CodeFunction2's Parameters collection.
        /// </summary>
        /// <param name="codeFunction"></param>
        /// <returns></returns>
        public static IEnumerable<CodeParameter> GetParameters(CodeFunction2 codeFunction)
        {
            return codeFunction.Parameters.OfType<CodeParameter>();
        }

        /// <summary>
        ///    Sets the ProjectItemInfo type and typeplural value depending on the originating object type.
        /// </summary>
        /// <returns></returns>
        public static void SetProjectItemInfoType(ProjectItemInfo projectItem, object objectType)
        {
            if (objectType is CodeClass2)
            {
                var classType = (CodeClass2) objectType;

                if (IsController(classType))
                {
                    projectItem.Type = "Controller";
                    projectItem.TypePlural = "Controllers";
                }
                else if (IsWebApi(classType))
                {
                    projectItem.Type = "Web API Controller";
                    projectItem.TypePlural = "Web API Controllers";
                }
                else if (IsModel(classType))
                {
                    projectItem.Type = "Model";
                    projectItem.TypePlural = "Models";
                }
                else
                {
                    projectItem.Type = "Class";
                    projectItem.TypePlural = "Classes";
                }
            }
            else if (objectType is CodeInterface)
            {
                projectItem.Type = "Interface";
                projectItem.TypePlural = "Interfaces";
            }
            else if (objectType is CodeStruct2)
            {
                projectItem.Type = "Struct";
                projectItem.TypePlural = "Structs";
            }
        }

        /// <summary>
        ///     Returns true if a ProjectItem is a folder.
        /// </summary>
        /// <returns></returns>
        public static bool IsFolder(ProjectItem item)
        {
            return item.Kind == EnvDTEConstants.vsProjectItemKindPhysicalFolder;
        }

        /// <summary>
        ///     Returns true if a CodeClass2 is a controller.
        /// </summary>
        /// <returns></returns>
        public static bool IsController(CodeClass2 type)
        {
            for (; type.FullName != "System.Web.Mvc.Controller"; type = (CodeClass2) type.Bases.Item(1))
            {
                if (type.Bases.Count == 0)
                    return false;
            }
            return true;
        }

        /// <summary>
        ///     Returns true if a CodeClass2 is a web API controller.
        /// </summary>
        /// <returns></returns>
        public static bool IsWebApi(CodeClass2 type)
        {
            for (; type.FullName != "System.Web.Http.ApiController"; type = (CodeClass2) type.Bases.Item(1))
            {
                if (type.Bases.Count == 0)
                    return false;
            }
            return true;
        }

        /// <summary>
        ///     Returns true if a CodeClass2 is a model.
        /// </summary>
        /// <returns></returns>
        public static bool IsModel(CodeClass2 type)
        {
            if (type.Name.ToLower().Contains("model"))
            {
                return true;
            }

            return false;
        }


        /// <summary>
        ///     Returns true if a CodeClass2 is an async controller.
        /// </summary>
        /// <returns></returns>
        public static bool IsAsyncController(CodeClass2 type)
        {
            for (; type.FullName != "System.Web.Mvc.AsyncController"; type = (CodeClass2) type.Bases.Item(1))
            {
                if (type.Bases.Count == 0)
                    return false;
            }
            return true;
        }

        /// <summary>
        ///     Returns a ProjectItem from a Project based on a name.
        /// </summary>
        /// <returns></returns>
        public static ProjectItem GetProjectItem(Project project, string name)
        {
            return GetProjectItem(project.ProjectItems, name);
        }



        /// <summary>
        ///     Returns a ProjectItem from a Project based on a subPath.
        /// </summary>
        /// <returns></returns>
        public static ProjectItem GetProjectItem(ProjectItems items, string subPath)
        {
            ProjectItem current = null;
            foreach (var name in subPath.Split('\\'))
            {
                try
                {
                    // ProjectItems.Item() sometimes throws when it doesn't exist, so catch the exception
                    // to return null instead.
                    current = items.Item(name);

                    if (current == null) return null;
                }
                catch
                {
                    // If any chunk couldn't be found, fail
                    return null;
                }

                items = current.ProjectItems;
            }

            return current;
        }

        
    }


	public class MethodInfo : CommentItem
    {
        public List<ParameterInfo> ParameterInfos { get; set; } = new List<ParameterInfo>();
        public string Access { get; set; } = "";
        public string Name { get; set; } = "";
        public string ReturnType { get; set; } = "";

    }

	public class ParameterInfo
    {
        public string Name { get; set; } = "";
        public string Type { get; set; } = "";

    }

	public class ProjectItemInfo : CommentItem
    {
        public ProjectItemInfo()
        {

        }

        public List<UsingStatement> UsingStatements { get; set; } = new List<UsingStatement>();
        public List<PropertyInfo> PropertyInfos { get; set; } = new List<PropertyInfo>();
        public List<MethodInfo> MethodInfos { get; set; } = new List<MethodInfo>();

        public string Name { get; set; } = "";
        public string Type { get; set; } = "Unknown";
        public string TypePlural { get; set; } = "Unknowns";
        public string Namespace { get; set; } = "";
        public string Description { get; set; } = "";
        public string Folder { get; set; } = "";

    }

	public class PropertyInfo : CommentItem
    {
        public string Access { get; set; } = "";
        public string Name { get; set; } = "";
        public string Type { get; set; } = "";

    }

	public class UsingStatement
    {
        public string Namespace { get; set; } = "";
    }

	internal abstract class EnvDTEConstants
    {
        public const string vsProjectItemKindPhysicalFolder = "{6BB5F8EF-4483-11D3-8BCF-00C04F8EC28C}";
        public const string vsDocumentKindText = "{8E7B96A8-E33D-11D0-A6D5-00C04FB67F6A}";
        public const string vsViewKindCode = "{7651A701-06E5-11D1-8EBD-00A0C90F26EA}";
    }

	public abstract class CommentItem
    {
        public string Summary { get; set; } = "";
        public string Remarks { get; set; } = "";
        public string Example { get; set; } = "";
        public string ExampleCode { get; set; } = "";

        public string Test()
        {
            return "";
        }
    }

	public class Manager
    {
        private class Block
        {
            public String Name;
            public int Start, Length;
        }

        private Block currentBlock;
        private List<Block> files = new List<Block>();
        private Block footer = new Block();
        private Block header = new Block();
        private ITextTemplatingEngineHost host;
        private StringBuilder template;
        protected List<String> generatedFileNames = new List<String>();

        public static Manager Create(ITextTemplatingEngineHost host, StringBuilder template)
        {
            return (host is IServiceProvider) ? new VSManager(host, template) : new Manager(host, template);
        }

        public virtual bool FileOkToWrite(String fileName)
        {
            return true;
        }

        public void KeepGeneratedFile(String name)
        {
            name = Path.Combine(Path.GetDirectoryName(host.TemplateFile), name);
            generatedFileNames.Add(name);
        }

        public void StartNewFile(String name)
        {
            if (name == null)
                throw new ArgumentNullException("name");
            CurrentBlock = new Block { Name = name };
        }

        public void StartFooter()
        {
            CurrentBlock = footer;
        }

        public void StartHeader()
        {
            CurrentBlock = header;
        }

        public void EndBlock()
        {
            if (CurrentBlock == null)
                return;
            CurrentBlock.Length = template.Length - CurrentBlock.Start;
            if (CurrentBlock != header && CurrentBlock != footer)
                files.Add(CurrentBlock);
            currentBlock = null;
        }

        public virtual void Process(bool split)
        {
            if (split)
            {
                EndBlock();
                String headerText = template.ToString(header.Start, header.Length);
                String footerText = template.ToString(footer.Start, footer.Length);
                String outputPath = Path.GetDirectoryName(host.TemplateFile);
                files.Reverse();
                foreach (Block block in files)
                {
                    String fileName = Path.Combine(outputPath, block.Name);
                    String content = headerText + template.ToString(block.Start, block.Length) + footerText;
                    generatedFileNames.Add(fileName);
                    CreateFile(fileName, content);
                    template.Remove(block.Start, block.Length);
                }
            }
        }

        protected virtual void CreateFile(String fileName, String content)
        {
            if (IsFileContentDifferent(fileName, content))
                File.WriteAllText(fileName, content);
        }

        public virtual String GetCustomToolNamespace(String fileName)
        {
            return null;
        }

        public virtual String DefaultProjectNamespace
        {
            get { return null; }
        }

        protected bool IsFileContentDifferent(String fileName, String newContent)
        {
            return !(File.Exists(fileName) && File.ReadAllText(fileName) == newContent);
        }

        private Manager(ITextTemplatingEngineHost host, StringBuilder template)
        {
            this.host = host;
            this.template = template;
        }

        private Block CurrentBlock
        {
            get { return currentBlock; }
            set
            {
                if (CurrentBlock != null)
                    EndBlock();
                if (value != null)
                    value.Start = template.Length;
                currentBlock = value;
            }
        }

        private class VSManager : Manager
        {
            private EnvDTE.ProjectItem templateProjectItem;
            private EnvDTE.DTE dte;
            private Action<String> checkOutAction;
            private Action<IEnumerable<String>> projectSyncAction;
            private IVsQueryEditQuerySave2 queryEditSave;

            public override String DefaultProjectNamespace
            {
                get
                {
                    return templateProjectItem.ContainingProject.Properties.Item("DefaultNamespace").Value.ToString();
                }
            }

            public override String GetCustomToolNamespace(string fileName)
            {
                return dte.Solution.FindProjectItem(fileName).Properties.Item("CustomToolNamespace").Value.ToString();
            }

            public override void Process(bool split)
            {
                if (templateProjectItem.ProjectItems == null)
                    return;
                base.Process(split);
                projectSyncAction.EndInvoke(projectSyncAction.BeginInvoke(generatedFileNames, null, null));
            }

            public override bool FileOkToWrite(String fileName)
            {
                CheckoutFileIfRequired(fileName);
                return base.FileOkToWrite(fileName);
            }

            protected override void CreateFile(String fileName, String content)
            {
                if (IsFileContentDifferent(fileName, content))
                {
                    CheckoutFileIfRequired(fileName);
                    File.WriteAllText(fileName, content);
                }
            }

            internal VSManager(ITextTemplatingEngineHost host, StringBuilder template)
                : base(host, template)
            {
                var hostServiceProvider = (IServiceProvider)host;
                if (hostServiceProvider == null)
                    throw new ArgumentNullException("Could not obtain IServiceProvider");
                dte = (EnvDTE.DTE)hostServiceProvider.GetService(typeof(EnvDTE.DTE));
                if (dte == null)
                    throw new ArgumentNullException("Could not obtain DTE from host");
                templateProjectItem = dte.Solution.FindProjectItem(host.TemplateFile);
                checkOutAction = (String fileName) => dte.SourceControl.CheckOutItem(fileName);
                projectSyncAction = (IEnumerable<String> keepFileNames) => ProjectSync(templateProjectItem, keepFileNames);
                queryEditSave = (IVsQueryEditQuerySave2)hostServiceProvider.GetService(typeof(SVsQueryEditQuerySave));
            }

            private static void ProjectSync(EnvDTE.ProjectItem templateProjectItem, IEnumerable<String> keepFileNames)
            {
                var keepFileNameSet = new HashSet<String>(keepFileNames);
                var projectFiles = new Dictionary<String, EnvDTE.ProjectItem>();
                var originalFilePrefix = Path.GetFileNameWithoutExtension(templateProjectItem.get_FileNames(0)) + ".";
                foreach (EnvDTE.ProjectItem projectItem in templateProjectItem.ProjectItems)
                    projectFiles.Add(projectItem.get_FileNames(0), projectItem);

                // Remove unused items from the project
                foreach (var pair in projectFiles)
                    if (!keepFileNames.Contains(pair.Key) && !(Path.GetFileNameWithoutExtension(pair.Key) + ".").StartsWith(originalFilePrefix))
                        pair.Value.Delete();

                // Add missing files to the project
                foreach (String fileName in keepFileNameSet)
                    if (!projectFiles.ContainsKey(fileName))
                        templateProjectItem.ProjectItems.AddFromFile(fileName);
            }

            private void CheckoutFileIfRequired(String fileName)
            {
                if (queryEditSave != null)
                {
                    uint pfEditVerdict;
                    queryEditSave.QuerySaveFile(fileName, 0, null, out pfEditVerdict);
                }
                else
                {
                    var sc = dte.SourceControl;
                    if (sc != null && sc.IsItemUnderSCC(fileName) && !sc.IsItemCheckedOut(fileName))
                        checkOutAction.EndInvoke(checkOutAction.BeginInvoke(fileName, null, null));
                }
            }
        }
    }

#>
